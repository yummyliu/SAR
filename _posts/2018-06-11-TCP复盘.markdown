---
layout: post
title: 
date: 2018-06-11 16:30
header-img: "img/head.jpg"
categories: jekyll update
tags:
typora-root-url: ../../SAR
---

# TCP çŠ¶æ€è½¬æ¢å›¾

![](/image/tcp.gif)

### 3æ¬¡æ¡æ‰‹ðŸ¤ï¼š

1. ## clientå‘é€SYNï¼Œè¯·æ±‚è¿žæŽ¥

2. serveræŽ¥æ”¶SYNï¼Œæ”¾å…¥SYN QUEUEä¸­ï¼›ç»™clientè¿”å›ž SYN+ACK

3. clientå‘é€ACKï¼Œå…ˆå’ŒESTABLISHEDçš„è¿žæŽ¥å¯¹æ¯”ï¼Œç„¶åŽå’Œsyn queueä¸­çš„å¯¹æ¯”ï¼›å¯¹æ¯”æˆåŠŸï¼Œsyn queueä¸­çš„slotåˆ æŽ‰ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„inet_sockï¼Œæ”¾åˆ°ACCEPT QUEUEé˜Ÿåˆ—ä¸­ï¼›**è¿žæŽ¥å»ºç«‹æˆåŠŸ**

4. å½“applicationè°ƒç”¨acceptçš„æ—¶å€™ï¼Œç›¸åº”çš„socketså‡ºåˆ—ï¼Œèµ‹äºˆç»™application

   ![](/image/all-1.jpeg)

   è¿™å°±æ˜¯é€šå¸¸çš„ä¸‰æ¬¡æ¡æ‰‹ï¼›ä½†æ˜¯å¦‚æžœè®¾ç½®äº†`TCP_FASTOPEN`å’Œ`TCP_DEFER_ACCEPT`å°±æœ‰ç‚¹ä¸ä¸€æ ·

##### TCP_FASTOPEN

###### client normal

```c
/* create socket file descriptor */
fd = socket(domain, type, protocol);

/* connect to the target server/port */
connect(fd,...);

/* send some data */
send(fd, buf, size);

/* wait for some reply and read into a local buffer */ 
while ((bytes  = recv(fd, ...))) {
    ...
}
```

###### client fastopen

```c
/* create the socket */
fd = socket();

/* connect and send out some data */
sendto(fd, buffer, buf_len, MSG_FASTOPEN, ...);

/* write more data */
send(fd, buf, size);

/* wait for some reply and read into a local buffer */ 
while ((bytes  = recv(fd, ...))) {
    ...
}
```

###### server normal

```c
/* create the socket */
fd = socket();

/* connect and send out some data */
bind(fd, addr, addrlen);

/* this socket will listen for incoming connections */
listen(fd, backlog);
```

server fastopen

```c
/* 
 * A generic protection in case you include this 
 * from multiple files 
 */
#ifndef _KERNEL_FASTOPEN
#define _KERNEL_FASTOPEN

/* conditional define for TCP_FASTOPEN */
#ifndef TCP_FASTOPEN
#define TCP_FASTOPEN   23
#endif

/* conditional define for MSG_FASTOPEN */
#ifndef MSG_FASTOPEN
#define MSG_FASTOPEN   0x20000000
#endif

#endif

/* a hint value for the Kernel */
int qlen = 5;

/* create the socket */
fd = socket();

/* bind the address */
bind(fd, addr, addrlen);

/* change the socket options to TCO_FASTOPEN */
setsockopt(sockfd, SOL_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen));

/* this socket will listen for incoming connections */
listen(fd, backlog);
```

é»˜è®¤ç³»ç»Ÿå…³é—­fastopenï¼›

æ‰“å¼€ï¼š`echo 1 > /proc/sys/net/ipv4/tcp_fastopen`

##### TCP_DEFER_ACCEPT

ä¸‰æ¬¡æ¡æ‰‹çš„ç¬¬äºŒæ­¥ä¹‹åŽï¼Œserveréœ€è¦ç­‰å¾…ä¸€ä¸ªackï¼Œæ‰èƒ½å»ºç«‹è¿žæŽ¥ï¼›è€Œä¹‹åŽæ‰ä¼šæœ‰real dataï¼›è¿™åœ¨å»ºç«‹tcpè¿žæŽ¥çš„æ—¶å€™ï¼Œæ¯”è¾ƒè€—æ—¶ï¼›

æ‰“å¼€äº†TCP_DEFER_ACCEPTä¹‹åŽï¼Œserveråœ¨æŽ¥æ”¶åˆ°SYN+ACKåŒ…ä¹‹åŽï¼Œä¸ä¼šç­‰å¾…ackï¼Œç›´æŽ¥ç­‰å¾…real dataåŒ…ï¼›è¿™èƒ½å‡å°‘è¿žæŽ¥å»ºç«‹æ—¶çš„delayï¼›

### å››æ¬¡æŒ¥æ‰‹ðŸ‘‹

åœ¨Linuxä¸­ï¼Œä¸€åˆ‡çš†æ–‡ä»¶ï¼ŒSocketä¹Ÿä¸ä¾‹å¤–ï¼›ä¸€ä¸ªæˆåŠŸå»ºç«‹çš„Socketæ–‡ä»¶ï¼Œæ˜¯ç”±ä¸¤å¯¹IP:Portç¡®å®šçš„ï¼›å½“å…¶ä¸­ä¸€æ–¹TCP Closeçš„æ—¶å€™ï¼Œå°±å¼€å§‹äº†è¿™ä¸ªSocketçš„å››æ¬¡æŒ¥æ‰‹çš„å…³é—­æµç¨‹ï¼Œå¦‚ä¸‹ï¼š

```
     TCP A                                                TCP B

  0.  ESTABLISHED                                          ESTABLISHED

  1.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

  2.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  3.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

  4.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

  5.  (2 MSL)
      CLOSED       
```

ðŸ‘‹ï¼šå‘èµ·Closeçš„ä¸€ç«¯Aï¼Œæ„å‘³ç€æˆ‘æ²¡æœ‰ä»»ä½•æ•°æ®éœ€è¦SENDäº†ï¼Œä½†æ˜¯åœ¨å‘èµ·Closeä¹‹åŽè¿˜æ˜¯ä¼šRecvï¼Œç›´åˆ°è¢«é€šçŸ¥å¦ä¸€ç«¯ä¹ŸCloseäº†ï¼›

ðŸ‘‹ðŸ‘‹ï¼šBæ”¶åˆ°FINä¿¡å·ï¼Œè¿›å…¥CLOSE_WAITçŠ¶æ€ï¼Œå¹¶å›žå¤ACKï¼›TCPæ˜¯å¯é çš„ï¼Œæ­¤æ—¶Bä¼šä¿è¯å°†Bufferä¸­çš„æ•°æ®ï¼Œåœ¨Bå…³é—­ä¹‹å‰å‘é€å‡ºåŽ»ï¼Œ*è¿™é‡Œè¦ç¡®ä¿è‡ªå·±ä¼šåŠæ—¶å…³é—­ï¼ˆ60sä¹‹å†…ï¼‰è¿™äº›CLOSE_WAITçŠ¶æ€çš„socketï¼Œå¦åˆ™ä¼šsocketæ³„éœ²*ï¼›

ðŸ‘‹ðŸ‘‹ðŸ‘‹ï¼šTCPæ”¶åˆ°ä¸€ä¸ªFINä¿¡å·ï¼Œä¼šå›žå¤ä¸€ä¸ªACKï¼›ä½†æ˜¯ä¸ä¼šç«‹é©¬å‘é€è‡ªå·±çš„FINä¿¡å·ï¼Œç›´åˆ°è‡ªèº«çš„userä¹ŸCloseè¿™ä¸ªtcpè¿žæŽ¥ï¼›

ðŸ‘‹ðŸ‘‹ðŸ‘‹ðŸ‘‹ï¼šBç«¯ä¸»åŠ¨å‘èµ·Closeï¼Œç»™Aå‘ä¸€ä¸ªFINï¼Œä¸€èµ·å…³é—­

> åœ¨åŽŸæ¥çš„TCPåè®®ä¸­ï¼Œæ˜¯ä¸å…è®¸ä»ŽFIN_WAIT_2çŠ¶æ€è‡ªåŠ¨è½¬æ¢çš„ï¼›FIN_WAIT_2åº”è¯¥æŽ¥ç€è¿è¡Œï¼Œç›´åˆ°å¦ä¸€ç«¯å·²ç»æ¸…ç†å®Œæ¯•äº†ã€‚ä½†æ˜¯å®žé™…ä¸Šç»è¿‡`tcp_fin_timeout`æ—¶é—´ï¼Œå¦‚æžœæ”¶ä¸åˆ°å¦ä¸€ç«¯çš„finæŽ§åˆ¶ä¿¡å·ï¼Œä¼šå¼ºåˆ¶å…³é—­è‡ªå·±ï¼Œä½ç½®æ”¾ç½®dosæ”»å‡»ï¼›
>
> ```
> tcp_fin_timeout (integer; default: 60)
>       This specifies how many seconds to wait for a final FIN packet
>       before the socket is forcibly closed.  This is strictly a
>       violation of the TCP specification, but required to prevent
>       denial-of-service attacks.
> ```



[ref](https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm)

[ref](http://edsiper.linuxchile.cl/blog/2013/02/21/linux-tcp-fastopen-in-your-sockets/)

[ref](https://blog.cloudflare.com/syn-packet-handling-in-the-wild/)

[ref](https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification/)

[ref](http://www.freesoft.org/CIE/Course/Section4/11.htm)