---
layout: post
title: concurrency in C++11
date: 2020-02-11 16:50
categories:
  - Linux
  - C++
typora-root-url: ../../layamon.github.io
---
* TOC
{:toc}
ä¸€ç›´å°±æ˜¯é‡è·¯å­c++ï¼Œä¸»è¦å°±æ˜¯ä»¥c++98çš„æ–¹å¼å†™ä»£ç ï¼›å‰æ®µæ—¶é—´çœ‹äº†MySQL8ä¸­çš„redologæ— é”ä¼˜åŒ–ï¼Œå¯¹å…¶ä¸­c++11çš„å¹¶å‘æ¡†æ¶çš„è¿ç”¨å°è±¡æ·±åˆ»ï¼Œå†³å®šè¦äº†è§£ä¸€ä¸‹C++11çš„æ–°ä¸œè¥¿äº†ï¼Œè·Ÿä¸Šæ½®æµğŸ˜‚ã€‚è¿™é‡Œå°±ä»å¹¶å‘è¿™å—å¼€å§‹çœ‹å§ï¼Œå…ˆè¡¥è¡¥åŸºç¡€çŸ¥è¯†ï¼

# å…³äºé”

å¹¶å‘ç¼–ç¨‹ä¸­æœ€å¸¸è§çš„æ¦‚å¿µå°±æ˜¯åŒæ­¥ï¼Œè€Œå®ç°åŒæ­¥çš„æ–¹å¼æœ‰å¾ˆå¤šç§ï¼Œæœ‰äº’æ–¥é”ï¼ˆmutexï¼‰ï¼ŒåŸå­å˜é‡ï¼ˆatomicï¼‰ï¼Œè‡ªæ—‹é”ï¼ˆspinlockï¼‰ï¼Œä¿¡å·é‡ï¼ˆsingalï¼‰ï¼Œè¯»å†™é”ï¼ˆshare/exclusive lockï¼‰ç­‰ç­‰ã€‚æœ¬æ–‡ä¸»è¦è®¨è®ºå‰ä¸‰ç§ï¼š

+ äº’æ–¥é”ï¼šmutexéœ€è¦é™·å…¥å†…æ ¸æ€ï¼Œå­˜åœ¨ä¸Šä¸‹æ–‡åˆ‡æ¢çš„ä»£ä»·ï¼Œä¸»è¦ä»£ä»·åœ¨cpu-sysã€‚
+ è‡ªæ—‹é”ï¼šspinlocké€šå¸¸åŸºäºCASç­‰åŸå­æ“ä½œå®ç°ï¼Œå¦‚æœå½“ä¸‹æ²¡æœ‰å–åˆ°é”ï¼Œé‚£ä¹ˆä¼šåœ¨ç”¨æˆ·æ€è‡ªæ—‹ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œé¿å…é¢‘ç¹é™·å…¥å†…æ ¸æ€ï¼Œä»£ä»·åœ¨cpu-usrã€‚
+ åŸå­å˜é‡ï¼šå°è£…äº†åŸå­æ“ä½œçš„å˜é‡ï¼Œä¸éœ€è¦é”ï¼Œä¹Ÿèƒ½ä¿è¯å¹¶å‘æ›´æ–°çš„æ­£ç¡®æ€§ï¼›å‰ä¸¤ä¸ªå¯ç”¨åœ¨æŸæ®µä¸´ç•ŒåŒºçš„äº’æ–¥ä¸Šï¼ŒåŸå­å˜é‡çš„äº’æ–¥ä¸´ç•ŒåŒºå¯è®¤ä¸ºç¼©å°åˆ°ä¸€ä¸ªå˜é‡çš„æ›´æ–°ã€‚

ä¸‹é¢å¯¹è¿™ä¸‰ç±»è¿›è¡Œç®€å•å±•å¼€ã€‚

## spinlock

è‡ªæ—‹é”çš„æ¦‚å¿µæ˜¯åœ¨PostgreSQLä¸­äº†è§£åˆ°çš„ï¼Œè‡ªæ—‹é”ï¼ˆSpinLockï¼‰ä½œä¸ºPostgreSQLæœ€åº•å±‚çš„é”ï¼ˆå…³äºPostgreSQLçš„é”ï¼Œå¯è§å¦ä¸€ç¯‡â€”â€”[Lock in PG](http://liuyangming.tech/05-2018/lock-PostgreSQL.html)ï¼‰ï¼Œå®ƒçš„å®ç°æ˜¯å’Œæ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶ç¯å¢ƒç›¸å…³çš„ã€‚åœ¨PostgreSQLä¸­ï¼Œå®ç°äº†ä¸¤ç§SpinLockï¼š

- Hardware-dependentï¼Œåˆ©ç”¨TASæŒ‡ä»¤é›†å®ç°(s_lock);

  ```c
  static __inline__ int
  tas(volatile slock_t *lock)
  {
  	register slock_t _res = 1;
  
  	__asm__ __volatile__(
  		"	lock			\n"
  		"	xchgb	%0,%1	\n"
  :		"+q"(_res), "+m"(*lock)
  :		/* no inputs */
  :		"memory", "cc");
  	return (int) _res;
  }
  ```

  åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼ŒCPUæœ‰æ—¶ä¸ä¼šä»å†…å­˜è¯»å–ï¼Œä¼šç›´æ¥ä»å¯„å­˜å™¨ä¸­è¯»å–å˜é‡å€¼ï¼›é‚£ä¹ˆï¼Œå®šä¹‰å˜é‡ä¸ºvolatileï¼Œè¡¨ç¤ºè¿™ä¸ªå˜é‡æ˜¯æ˜“å¤±çš„ï¼Œæ‰€ä»¥ä¼šç¼–è¯‘å™¨ä¼šå¼ºåˆ¶æ¯æ¬¡éƒ½å»å†…å­˜ä¸­å–åŸå§‹å€¼ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‹¿å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œå¸¸ç”¨åœ¨é”å˜é‡ç­‰å¯¹è±¡ä¸Šã€‚

- Hardware-independentï¼Œåˆ©ç”¨PostgreSQLå®šä¹‰çš„ä¿¡å·é‡PGSemaphoreå®ç°(spin)ã€‚

  ```c
  int
  tas_sema(volatile slock_t *lock)
  {
  	int			lockndx = *lock;
  
  	if (lockndx <= 0 || lockndx > NUM_SPINLOCK_SEMAPHORES)
  		elog(ERROR, "invalid spinlock number: %d", lockndx);
  	/* Note that TAS macros return 0 if *success* */
  	return !PGSemaphoreTryLock(SpinlockSemaArray[lockndx - 1]);
  }
  /*
   * PGSemaphoreTryLock
   *
   * Lock a semaphore only if able to do so without blocking
   */
  bool
  PGSemaphoreTryLock(PGSemaphore sema)
  {
  	int			errStatus;
  
  	/*
  	 * Note: if errStatus is -1 and errno == EINTR then it means we returned
  	 * from the operation prematurely because we were sent a signal.  So we
  	 * try and lock the semaphore again.
  	 */
  	do
  	{
  		errStatus = sem_trywait(PG_SEM_REF(sema));
  	} while (errStatus < 0 && errno == EINTR);
  
  	if (errStatus < 0)
  	{
  		if (errno == EAGAIN || errno == EDEADLK)
  			return false;		/* failed to lock it */
  		/* Otherwise we got trouble */
  		elog(FATAL, "sem_trywait failed: %m");
  	}
  
  	return true;
  }
  ```
  

ä¸€èˆ¬æ¥è¯´ï¼Œè‡ªæ—‹é”éœ€è¦å ç”¨CPUèµ„æºè¿›è¡Œä¸æ–­çš„æ£€æŸ¥ï¼Œå¯¹äºæ¯”è¾ƒè€—æ—¶çš„æ“ä½œï¼Œé€šå¸¸ä¸å»ºè®®ä½¿ç”¨ï¼Œä¼šæµªè´¹å¤ªå¤šçš„CPUèµ„æºã€‚

è‡ªæ—‹é”é€šå¸¸æ˜¯ç¬¬ä¸€ç§å®ç°ï¼Œä¼šä½¿ç”¨ä¸€ä¸ªvolatileå˜é‡ï¼šlockvarï¼Œè¡¨ç¤ºè¯¥å˜é‡ææ˜“æ”¹å˜ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±ä¸ä¼šå¯¹è¯¥å˜é‡è¿›è¡Œä»»ä½•ä¼˜åŒ–ï¼Œæ¯”å¦‚ä¹±åºï¼Œ é¿å…å½±å“åŸæœ‰é€»è¾‘ã€‚åœ¨æ‰§è¡Œä¸­ï¼Œlockvaræ˜¯ç”±loadåŠ è½½åˆ°cpu  coreçš„å¯„å­˜å™¨ä¸­ï¼Œç„¶åé€šè¿‡storeæŒ‡ä»¤å†™åˆ°ç£ç›˜ä¸­ï¼Œå°½ç®¡ç¼–è¯‘å™¨ä¸ä¼šä¹±åºä¼˜åŒ–ï¼Œä½†æ˜¯æµæ°´çº¿æ‰§è¡Œçš„æ—¶å€™è¿˜æ˜¯å¯èƒ½ä¼šä¹±åºé‡æ’ã€‚

å› ä¸ºcpuçš„æµæ°´çº¿ä¼šä¹±åºæ‰§è¡Œï¼Œä½†æ˜¯ä¸ºäº†ä¿è¯memory orderæ­£ç¡®æ€§ï¼Œéœ€è¦ä¿è¯storeä¹‹åçš„loadï¼Œä¸ä¼šæå‰æ‰§è¡Œï¼›

> memory orderï¼šæŒ‡çš„æ˜¯loadå’ŒstoreæŒ‡ä»¤çš„ç›¸å¯¹é¡ºåºã€‚Memory Order Violation: A load is executed before a prior store, reads the wrong value

å› æ­¤ï¼Œåœ¨å®é™…æ‰§è¡Œä¸­ï¼Œå¦‚æœæŸä¸ªcore loadäº†æŸä¸ªåœ°å€çš„å†…å®¹åï¼Œå¹¶ä¸”æŒ‰ç…§ä¹±åºé‡æ’äº†æŒ‡ä»¤ï¼›é‚£ä¹ˆï¼Œåœ¨è¿™ä¹‹åï¼Œå¦ä¸€ä¸ªcoreå¯¹åŒä¸€åœ°å€æ‰§è¡Œäº†storeï¼›é‚£ä¹ˆæ‰§è¡ŒloadæŒ‡ä»¤çš„åŸcoreçš„æµæ°´çº¿é¡ºåºå¯èƒ½å‘ç”Ÿmemory order violateï¼Œéœ€è¦é‡æ’ï¼ˆè¿™æ˜¯å¾ˆè´¹æ—¶çš„ï¼‰ã€‚

åœ¨spin lockåœºæ™¯ä¸­ï¼Œè¿™ç»å¸¸å‘ç”Ÿï¼›ç­‰é”çš„coreä¸æ–­æ‰§è¡Œloadï¼Œæ‰§è¡Œäº†å‡ æ¬¡éƒ½å¤±è´¥åï¼Œç³»ç»ŸæŒ‰ç…§å¸¸ç†æ¨æµ‹å‡ºåç»­åº”è¯¥éƒ½å¤±è´¥ï¼Œå°±æŒ‰ç…§å¤±è´¥çš„é€»è¾‘æ’åˆ—äº†loadæŒ‡ä»¤ï¼›ä½†æ˜¯å¯èƒ½åˆšæ’åˆ—å¥½ï¼Œå¦ä¸€ä¸ªcoreå°±è§£é”äº†ï¼Œå³ï¼Œæ‰§è¡Œäº†storeå‘½ä»¤ï¼›é‚£ä¹ˆspink lock å¯¹åº”çš„loadæµæ°´çº¿ï¼Œå°±å¾—é‡æ’ï¼›ä¸ºäº†é¿å…è¿™ä¸ªä»£ä»·ï¼Œintelçš„cpuå¼•å…¥äº†pauseæŒ‡ä»¤ï¼Œè¿™æ ·loadå…ˆä¸ç€æ€¥é¢„æµ‹æ’åˆ—ã€‚

## atomic

PostgreSQLåœ¨9.6ç‰ˆæœ¬ä¸­ï¼Œå°†bufferpoolä¸­çš„spinlockæ›¿æ¢ä¸ºatomic operationsï¼ˆ[commitlog](https://commitfest.postgresql.org/9/408/#)ï¼‰ï¼Œä¾‹å¦‚ä¸‹é¢çš„commitlogï¼š

```c
-		LockBufHdr(buf);
-		buf->refcount++;
+		pg_atomic_add_fetch_u32(&buf->refcount, 1);
+
```

å…¶å°†`refcount`è®¾è®¡æˆä¸€ä¸ªåŸå­å˜é‡ï¼Œå€ŸåŠ©åº•å±‚çš„add_fetchåŸå­æŒ‡ä»¤è¿›è¡Œæ“ä½œï¼›ç›¸æ¯”äºlockï¼Œç±»ä¼¼casçš„åŸå­æ“ä½œæœ‰æ˜¯ä¹è§‚çš„ã€‚å¾ˆå¤šç”¨lockå®ç°çš„åœ°æ–¹ï¼Œå¯ä»¥å˜æˆåŸå­æ“ä½œï¼Œè¿™æ ·èƒ½å¤Ÿå‡å°‘é”çš„é¢å¤–ä»£ä»·ï¼Œå®ç°lock-freeï¼›ä½†æ˜¯ä¸ç­‰äºwait-freeã€‚åœ¨gccä¸­ï¼Œæä¾›äº†ç±»ä¼¼çš„æ“ä½œï¼Œæ¯”å¦‚`__sync_lock_test_and_set`ã€‚è€Œåœ¨åœ¨C++11ä¸­æœ‰åŸå­å˜é‡ç±»å‹ï¼Œæä¾›äº†å„ç§åŸå­æ“ä½œï¼›åŸå­æ“ä½œæ˜¯æ“ä½œç³»ç»Ÿæä¾›æœ€å°çš„ä¸”ä¸å¯å¹¶è¡ŒåŒ–çš„æŒ‡ä»¤ã€‚

PostgreSQLç±»ä¼¼çš„åŸå­æ“ä½œæœ‰ï¼š

+ Test and setï¼š`pg_atomic_test_set_flag_impl`;
+ Compare and exchangeï¼š`pg_atomic_compare_exchange_u32_impl`;
+ Fetch and addï¼š`pg_atomic_fetch_add_u32_impl`ã€‚

åœ¨InnoDB5.7çš„os0syncä¸­åŒæ ·å°è£…äº†åŸå­æ“ä½œï¼Œè€Œåœ¨8ä¸­ï¼Œç›´æ¥ä½¿ç”¨äº†C++11çš„åŸå­ç±»å‹ã€‚Â·

## Mutex

å…³äºMutexï¼Œä¸»è¦äº†è§£ä¸€ä¸‹futexè°ƒç”¨ï¼Œ**futex**æ˜¯**Fast Userspace muTEX**çš„ç®€ç§°ã€‚æ˜¯åœ¨2003ç”±IBMçš„å·¥ç¨‹å¸ˆå¼•å…¥åˆ°Kernelä¸­çš„ï¼Œä¸»è¦ç”¨äºå‡å°é«˜å¹¶å‘ä¸‹é”åŒæ­¥æ˜¯system callçš„ä»£ä»·ã€‚

ç”±äºåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œé”ä¸Šå¹¶æ²¡æœ‰ç«äº‰ã€‚åº”ç”¨å¯åŸºäºç¡¬ä»¶æä¾›çš„åŸå­æ“ä½œå°±å¯ä»¥è¿›è¡Œé”èµ„æºçš„å ç”¨äº†ã€‚

> Most modern processors have built-in atomic instructions implemented in HW. For example on Intel architectures `cmpxhg` is an instruction. While it's not as cheap as non-atomic instructions (especially in multi-core systems), it's significantly cheaper than system calls.

å¯¹äºå°‘éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œè·å–é”æ—¶ç¡®å®å­˜åœ¨ç«äº‰ï¼Œæ­¤æ—¶é€šè¿‡åŸå­æ“ä½œè·å–é”å¯èƒ½ä¼šå¤±è´¥ã€‚å¦‚æœé”è·å–å¤±è´¥ï¼Œæœ‰ä¸¤ç§å¤„ç†æ–¹æ¡ˆï¼š

+ æ–¹æ¡ˆä¸€æ˜¯ä¸æ–­è‡ªæ—‹æ£€æŸ¥é”èµ„æºæ˜¯å¦å¯ç”¨ï¼Œä½†æ˜¯è¿™æ ·ä¼šæµªè´¹CPUèµ„æºï¼›
+ æ–¹æ¡ˆäºŒå°±å¯ç”¨å…ˆå°†å½“å‰çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰çŠ¶æ€å˜ä¸ºsleepï¼Œç­‰åˆ°é”èµ„æºé‡Šæ”¾äº†ï¼Œå†å”¤é†’å¤„ç†ï¼Œé‚£ä¹ˆå¦‚ä½•è¿›è¡Œsleep/wakeupå‘¢ï¼Ÿè¿™é‡Œå°±éœ€è¦`futex`äº†ã€‚

```c
#include <linux/futex.h>
#include <sys/time.h>

int futex(int *uaddr, int futex_op, int val,
          const struct timespec *timeout,   /* or: uint32_t val2 */
          int *uaddr2, int val3);
```

futexè°ƒç”¨æ¥å£å¦‚ä¸Šï¼Œfutex_opå‚æ•°å®šä¹‰äº†å¤šç§ä¸åŒçš„æ“ä½œï¼Œæ¯”å¦‚`FUTEX_WAIT`å’Œ`FUTEX_WAKE`ï¼Œä¸€ä¸ªæ˜¯ç­‰å¾…`uaddr`å¤„çš„æ•°æ®ç­‰äºvalï¼Œä¸€ä¸ªæ˜¯å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰ã€‚

![image-20200216101837409](/image/2020-0215-futex.png)

è¿™æ ·å®é™…ä¸Šï¼Œå†…æ ¸å¸®ç”¨æˆ·æ€çº¿ç¨‹ç»´æŠ¤äº†ä¸€ä¸ªé”é˜Ÿåˆ—ï¼Œå¦‚ä¸Šå›¾ï¼Œthreadé€šè¿‡`FUTEX_WAIT`é€šçŸ¥å†…æ ¸å°†è‡ªå·±æŒ‚èµ·å¹¶æ’é˜Ÿï¼Œç„¶åç”±å¦å¤–ä¸€ä¸ªè¿›ç¨‹é€šè¿‡`FUTEX_WAKE`é‡Šæ”¾è¯¥é”ï¼Œå¹¶å”¤é†’é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹ï¼ˆå”¤é†’æ—¶ï¼Œå¯é€šè¿‡å‚æ•°æŒ‡å®šå”¤é†’æ•°é‡ï¼‰ï¼›è¿™å°±æ˜¯ä¸Šé¢æ‰€è¿°çš„æ–¹æ¡ˆäºŒçš„ç®€å•åŸç†ï¼Œé¿å…äº†é˜Ÿåˆ—ä¸­æ¯ä¸ªçº¿ç¨‹éƒ½ä¸æ–­çš„æ£€æŸ¥åŸå­å˜é‡ï¼Œè€Œæ¶ˆè€—CPUèµ„æºï¼›å¹¶ä¸”Futexå¤§éƒ¨åˆ†æ˜¯åœ¨ç”¨æˆ·æ€å®Œæˆçš„ï¼Œå‡å°‘äº†é™·å…¥å†…æ ¸æ€çš„ä»£ä»·ã€‚

> å®é™…ä¸ŠFutexæ˜¯é€šè¿‡ä¸€ä¸ªhash tableç»´æŠ¤å„ä¸ªkeyï¼Œå¦‚ä¸‹å›¾ï¼Œè¯¦ç»†çš„å®ç°é€»è¾‘ï¼Œæœ‰å…´è¶£å¯ä»¥ç»§ç»­äº†è§£ï¼š
>
> ![Futex implementation diagram from LWN](/image/2020-0215-futex-lwn-diagram.png)
>
> è€Œä¸”futexå¯ä½œç”¨çš„å…±äº«èµ„æºä¸ä»…ä»…æ˜¯å¤šçº¿ç¨‹å¹¶è¡Œä¸­çš„å…±äº«å˜é‡ï¼Œè¿˜æœ‰å¤šè¿›ç¨‹ä¸­çš„èµ„æºï¼Œæ¯”å¦‚mmap(2) æˆ– shmat(2)åˆ›å»ºçš„å…±äº«å†…å­˜ï¼Œ
>

futexä¸€èˆ¬ç”¨åœ¨ä½å†²çªçš„é”åŒæ­¥åœºæ™¯ä¸­ã€‚åœ¨å®é™…ä»£ç ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šç”¨åˆ°`mutex`è¿›è¡Œçº¿ç¨‹äº’æ–¥ï¼Œmutexåº•å±‚å°±æ˜¯åŸºäºfutexå’Œatomicså®ç°çš„ï¼Œå³ï¼Œé€šè¿‡atomicså­˜å‚¨é”å­—èŠ‚ï¼Œç„¶åé€šè¿‡futexè¿›è¡Œatomicsçš„æ£€æµ‹ï¼Œ[è¿™é‡Œ](https://github.com/eliben/code-for-blog/blob/master/2018/futex-basics/mutex-using-futex.cpp)æœ‰ä¸ªç®€å•å®ç°æ ·ä¾‹ã€‚å®é™…çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥å‚è§glibcä¸­çš„`pthread_mutex_t`ï¼Œç¿»çœ‹NPTLï¼ˆNative_POSIX_Thread_Libraryï¼‰çš„ä»£ç å¯ä»¥ä»æ³¨é‡Šä¸­äº†è§£ä¸€äºŒï¼ˆsysdeps/nptl/lowlevellock.hï¼‰ï¼š

```c
/* Low-level locks use a combination of atomic operations (to acquire and
   release lock ownership) and futex operations (to block until the state
   of a lock changes).  A lock can be in one of three states:
   0:  not acquired,
   1:  acquired with no waiters; no other threads are blocked or about to block
       for changes to the lock state,
   >1: acquired, possibly with waiters; there may be other threads blocked or
       about to block for changes to the lock state.

   We expect that the common case is an uncontended lock, so we just need
   to transition the lock between states 0 and 1; releasing the lock does
   not need to wake any other blocked threads.  If the lock is contended
   and a thread decides to block using a futex operation, then this thread
   needs to first change the state to >1; if this state is observed during
   lock release, the releasing thread will wake one of the potentially
   blocked threads.
 ..
 */
```

åŸºäºä»¥ä¸Šçš„äº†è§£ï¼ŒåŸºæœ¬å¯¹å¤šçº¿ç¨‹ä¸­çš„èµ„æºåŒæ­¥æœ‰äº†ç®€å•çš„äº†è§£ï¼Œè€Œåœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šæ¶‰åŠæ›´å¤šçš„é—®é¢˜ï¼›

2000å¹´ä»¥åï¼Œéšç€å¤„ç†å™¨æ¶æ„çš„å˜åŒ–ï¼Œå¾ˆå¤šç¼–ç¨‹è¯­è¨€éƒ½å†…å»ºäº†å¹¶è¡Œç¼–ç¨‹çš„æ”¯æŒï¼›è€Œåœ¨C++ä¸­ï¼Œä¸€èˆ¬è¿˜æ˜¯é€šè¿‡pthreadå’ŒOpenMPè¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹ï¼›åœ¨C++11ä¸­ï¼Œå¯¹å¹¶è¡Œç¼–ç¨‹æ¨¡å‹è¿›è¡Œäº†ç³»ç»Ÿçš„å°è£…ï¼Œä¸‹é¢å°±äº†è§£ä¸€ä¸‹C++11ä¸­çš„å¹¶è¡Œç¼–ç¨‹æ¨¡å‹ã€‚

# C++11å¹¶å‘ç¼–ç¨‹æ¡†æ¶

> *Concurrency* means that two or more calculations happen **within the same time frame**, and there is usually some sort of **dependency** between them. *Parallelism* means that two or more calculations happen **simultaneously**. Parallel is subset of Concurrency; 

åœ¨C++11ä¸­ï¼Œ`std::thread`è¿›è¡Œäº†è·¨å¹³å°çš„çº¿ç¨‹å°è£…ï¼›åŸæ¥é€šè¿‡pthreadçš„å¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œå°±å¯å˜ä¸ºè¿™æ ·äº†ï¼š

```c++
int main()
{
    int n = 0;
    std::thread my_thread(f1, n + 1); // pass by value
    my_thread.join();
}
```

ä¸‹é¢ï¼Œä»ä¸‰ä¸ªæ–¹é¢ï¼Œå¯¹C++çš„å¹¶å‘ç¼–ç¨‹æ¡†æ¶è¿›è¡Œç®€å•ä»‹ç»ï¼š

1. æ•°æ®çš„åŸå­æ“ä½œï¼Œatomic/memory_order
2. æ•°æ®çš„å…±äº«ä¸äº’æ–¥ï¼Œthread_local/mutex/condition_variable
3. çº¿ç¨‹çš„æ‰§è¡Œä¸é€€å‡ºï¼ŒCPU affinity/quick_exit

## æ•°æ®çš„åŸå­æ“ä½œ

### åŸå­ç±»å‹

ä¹‹å‰å¯¹å˜é‡çš„äº’æ–¥è®¿é—®æ˜¯é€šè¿‡lock/unlockæ„å»ºä¸€ä¸ªä¸´ç•ŒåŒºæ¥äº’æ–¥çš„ï¼Œè¿™æ ·ç¼–ç¨‹ç‰¹åˆ«éº»çƒ¦ã€‚åœ¨C++11ä¸­ï¼Œåœ¨æ ‡å‡†åº“å†…å¼•å…¥äº†å¤šçº¿ç¨‹çš„æ”¯æŒï¼Œæœ€é‡è¦çš„å°±æ˜¯åŸå­ç±»å‹çš„å¼•å…¥ã€‚

+ atomic_*å’Œ`atomic<T>`

> C11çš„æ–°å…³é”®å­—_Atomicæ˜¯åŒæ ·çš„é“ç†

åœ¨c++11ä¹‹å‰çš„åŸå­ç±»å‹æ˜¯é€šè¿‡å†…è”æ±‡ç¼–ä»£ç å®ç°ã€‚å¯¹äºæ¯ç§åŸå­ç±»å‹ï¼Œéƒ½æä¾›äº†åŸºæœ¬çš„åŸå­æ“ä½œï¼Œæ¯”å¦‚`test_and_set`ã€`fetch_and_add`ã€`compare_and_exchange`ç­‰ç­‰ã€‚

> ç›¸æ¯”äºå…¶ä»–åŸå­ç±»å‹ï¼Œautomic_flagçš„è®¿é—®æ˜¯lock-freeçš„ï¼Œå…¶åªæ”¯æŒä¸¤ç§åŸå­æ“ä½œï¼š`test_and_set`å’Œ`clear`ï¼Œä¸€èˆ¬åŸºäºatomic_flagå®ç°ä¸€ä¸ªspinlockã€‚
>
> ```c++
> std::atomic_flag lock = ATOMIC_FLAG_INIT;
> void lock(int n) {
>   	while(lock.test_and_set());
>    }
> void unlock(int n) {
> 	lock.clear();
>   }
> ```

### å†…å­˜é¡ºåºæ¨¡å‹

å†…å­˜é¡ºåºæ¨¡å‹åˆ†ä¸¤ç±»ï¼šè½¯ä»¶å±‚é¢å’Œç¡¬ä»¶å±‚é¢ã€‚

ç¡¬ä»¶å±‚é¢ä¸Šï¼ŒCPUåœ¨è¶…æ ‡é‡æµæ°´çº¿ï¼ˆ**Superscalar**ï¼‰æ‰§è¡Œä¸­ï¼Œä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸä¼šæ‰§è¡Œå¤šæ¡æŒ‡ä»¤ã€‚å¯¹äºä¸€äº›ç¡¬ä»¶ä¸Šæ²¡æœ‰ç›¸å…³æ€§çš„æŒ‡ä»¤ï¼Œè¿™ä¼šé€ æˆä»£ç æ‰§è¡Œé¡ºåºä¸åŸæ¥ä¸ä¸€æ ·ï¼›è½¯ä»¶å±‚é¢ä¸Šï¼Œåœ¨ä»£ç ç¼–è¯‘ä¸­ï¼Œç¼–è¯‘å™¨ä¹Ÿä¼šä¼šæ‰§è¡Œé‡æ–°æ’åˆ—æŒ‡ä»¤ï¼Œè¿›è¡Œä¹±åºæ‰§è¡Œçš„ä¼˜åŒ–ï¼›(å¤šå–)

è¿™éƒ½ä¼šé€ æˆå®é™…æ‰§è¡Œé¡ºåºä¸åŸæ¥ç¼–å†™çš„é¡ºåºä¸ä¸€è‡´çš„é—®é¢˜ã€‚è€Œå¦‚æœæˆ‘ä»¬è¦æ±‚æŸäº›è¯­å¥çš„æ‰§è¡Œé¡ºåºéœ€è¦å’Œçœ‹åˆ°çš„ä¸€æ ·ï¼Œè¿™å°±å«é¡ºåºä¸€è‡´çš„å†…å­˜æ¨¡å‹ï¼ˆSequential consistentï¼‰ã€‚ä¸åŒçš„å¤„ç†å™¨æ¶æ„çš„å†…å­˜æ¨¡å‹ä¸ä¸€æ ·ã€‚å¦‚æœæŒ‡ä»¤ä¸¥æ ¼æŒ‰ç…§é¡ºåºæ‰§è¡Œï¼Œè¿™å«å¼ºé¡ºåºçš„æ¶æ„ï¼ˆæ¯”å¦‚x86ï¼‰ï¼Œå¦åˆ™å«å¼±é¡ºåºï¼ˆæ¯”å¦‚PowerPCï¼ŒArmV7ç­‰ï¼‰ã€‚

é‚£ä¹ˆå¯¹äºå¼±é¡ºåºçš„æœºå™¨ï¼Œä¸ºäº†ä¿éšœæ‰§è¡Œçš„é¡ºåºï¼Œåœ¨æ±‡ç¼–æŒ‡ä»¤ä¸­æœ‰å†…å­˜æ …æ (**memory barrier**ï¼‰çš„æŒ‡ä»¤ï¼Œæ¯”å¦‚PowerPCçš„syncï¼Œåœ¨æ‰§è¡Œåˆ°å†…å­˜æ …æ æ—¶ï¼Œä¼šç­‰å¾…ä¹‹å‰çš„æŒ‡ä»¤éƒ½æ‰§è¡Œå®Œæˆåå†æ‰§è¡Œåé¢çš„æŒ‡ä»¤ã€‚memory barrierå¯è®¤ä¸ºæœ‰ä¸‰ç§ï¼š

1. full memory barrierï¼šè¯¥æŒ‡ä»¤å‰çš„acquire(read)/release(write)æŒ‡ä»¤å…¨éƒ¨å®Œæˆåï¼Œæ‰èƒ½æ‰§è¡Œåé¢çš„æŒ‡ä»¤ã€‚
2. acquire(read, load) memory barrierï¼šè¯¥æŒ‡ä»¤å‰çš„acquireæŒ‡ä»¤å…¨éƒ¨å®Œæˆåï¼Œæ‰èƒ½æ‰§è¡Œåé¢çš„æŒ‡ä»¤ã€‚
3. release(write, store) memory barrier:è¯¥æŒ‡ä»¤å‰çš„releaseæŒ‡ä»¤å…¨éƒ¨å®Œæˆåï¼Œæ‰èƒ½æ‰§è¡Œåé¢çš„æŒ‡ä»¤ã€‚

å¯¹äºåŸå­ç±»å‹é»˜è®¤æ˜¯full memory barrierï¼Œè¿™å¯èƒ½ä¼šé™åˆ¶å¹¶å‘æ€§èƒ½çš„æå‡ã€‚è€Œå¦‚æœæˆ‘ä»¬å¯ä»¥å¯¹äºæŸäº›åœºæ™¯å¹¶ä¸éœ€è¦åŸå­ç±»å‹ä¿è¯é¡ºåºä¸€è‡´æ€§ï¼Œåœ¨C++11ä¸­ï¼Œé€šè¿‡`memory_order`æ¥è®©ç¨‹åºå‘˜ä¸ºåŸå­æ“ä½œæŒ‡å®šå†…å­˜é¡ºåºï¼Œè¿™é‡Œçš„é¡ºåºå¯¹åº”çš„æ“ä½œéƒ½æ˜¯åŸå­ç±»å‹çš„å­˜å–æ“ä½œï¼Œæœ‰å¦‚ä¸‹6ç§ï¼š

+ `memory_order_relaxed`ï¼šä¸å¯¹æ‰§è¡Œé¡ºåºåšä»»ä½•ä¿è¯ï¼›
+ `memory_order_acquire`ï¼šæœ¬çº¿ç¨‹ä¸­ï¼Œåç»­çš„**æ‰€æœ‰**è¯»æ“ä½œéœ€è¦åœ¨å½“å‰æŒ‡ä»¤ç»“æŸåæ‰§è¡Œï¼›
+ `memory_order_release`ï¼šæœ¬çº¿ç¨‹ä¸­ï¼Œä¹‹å‰çš„**æ‰€æœ‰**å†™æ“ä½œéƒ½å®Œæˆåï¼Œæ‰èƒ½æ‰§è¡Œå½“å‰æŒ‡ä»¤ï¼›
+ `memory_order_acq_rel`ï¼šç»“åˆä¸Šä¸¤æ¡ï¼›
+ `memory_order_consume`ï¼šæœ¬çº¿ç¨‹ä¸­ï¼Œåç»­ä¸**æœ¬åŸå­å˜é‡ç›¸å…³**çš„è¯»å†™æ“ä½œï¼Œå¿…é¡»åœ¨æœ¬æŒ‡ä»¤å®Œæˆåæ‰§è¡Œï¼›
+ `memory_order_seq_cst`ï¼šå…¨éƒ¨è¯»å†™éƒ½æŒ‰é¡ºåºæ‰§è¡Œï¼Œé»˜è®¤å€¼ï¼›

å…·ä½“ä½¿ç”¨çš„æ—¶å€™ï¼Œæ˜¯é€šè¿‡å¤šè€…çš„è¯­ä¹‰ç»“åˆï¼Œå®Œæˆå¤šçº¿ç¨‹é—´çš„å†…å­˜å­˜å–çš„è¯­ä¹‰ï¼Œå¸¸è§çš„å°±å››ç§ï¼š`memory_order_acquire`å’Œ`memory_order_release`ç»å¸¸ç»“åˆä½¿ç”¨ï¼Œè¿™ç§å†…å­˜é¡ºåºæˆä¸º**release-acquireå†…å­˜æ¨¡å‹**ï¼›è€Œ`memory_order_consume`æ˜¯`memory_order_acquire`çš„æ›´åŠ å¼±åŒ–ç‰ˆæœ¬ï¼Œ`memory_order_release`å’Œ`memory_order_consume`å¯ä»¥å»ºç«‹å…³äºæŸåŸå­å˜é‡çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…é¡ºåºï¼Œè¿™ç§°ä¸º**release-consumeå†…å­˜æ¨¡å‹**ã€‚åŠ ä¸Š`memory_order_relaxed`çš„**æ¾æ•£å†…å­˜æ¨¡å‹**å’Œé»˜è®¤çš„**é¡ºåºä¸€è‡´å‹å†…å­˜æ¨¡å‹**ï¼Œæ˜¯c++11ä¸­å…¸å‹çš„å››ç§å†…å­˜æ¨¡å‹ã€‚

> å¦å¤–ï¼Œå¯¹äº`memory_order_acq_rel`å¸¸ç”¨åœ¨å®ç°CASï¼ˆcompare and swapï¼‰åŒæ­¥åŸè¯­ï¼Œä¹Ÿç§°ä¹‹ä¸º**acquire-releaseå†…å­˜é¡ºåºæ¨¡å‹**ã€‚

åœ¨MySQL8ä¸­ï¼Œå¯¹logæ¨¡å—è¿›è¡Œäº†å¤§é‡çš„é‡æ„ï¼Œå…¶ä¸­å°±åŒ…æ‹¬å¼‚æ­¥æ— é”åˆ·ç›˜çš„é€»è¾‘ï¼Œå…¶ä¸­ä½¿ç”¨äº†å¤§é‡çš„c++11çš„å¹¶è¡Œç¼–ç¨‹çš„ç‰¹æ€§ï¼Œå¯ä½œä¸ºå­¦ä¹ C++11å¾ˆå¥½å‚è€ƒï¼Œæ¯”å¦‚è¿™é‡Œå°±é€šè¿‡`memory_order_release`è¿›è¡Œå†…å­˜é¡ºåºçš„ä¿è¯ï¼š

```c++
 using atomic_lsn_t = std::atomic<lsn_t>;
...
/* Do not reorder writes above, below this line. For x86 this
 * protects only from unlikely compile-time reordering. */
 std::atomic_thread_fence(std::memory_order_release);
```

## æ•°æ®çš„å…±äº«ä¸äº’æ–¥

### çº¿ç¨‹æœ¬åœ°å­˜å‚¨

å¯¹äºæ ˆå†…å˜é‡ï¼Œè‚¯å®šå°±æ˜¯çº¿ç¨‹æœ¬åœ°çš„ï¼›ä½†æ˜¯å¯¹äºå…¨å±€å˜é‡ï¼Œä¸€èˆ¬å°±æ˜¯å…¨å±€å…±äº«çš„ï¼Œè€Œå¦‚æœæˆ‘ä»¬æƒ³å°†ä¸€äº›å…¨å±€å˜é‡å˜æˆçº¿ç¨‹æœ¬åœ°å­˜å‚¨çš„ï¼Œåœ¨ä¸€ä¸ªç¼–è¯‘å™¨ä¸­å¯ä»¥åŠ `__thread`å‰ç¼€ï¼Œè€Œåœ¨c++11ä¸­ï¼Œå¯¹å…¶è¿›è¡Œäº†ç»Ÿä¸€ï¼Œä½¿ç”¨`thread_local`å…³é”®å­—ï¼š

```c++
int thread_local errCode;
```

thread_localçš„å…·ä½“å®ç°æ–¹å¼ä¸åŒçš„ç¼–è¯‘å™¨ä¸ä¸€æ ·ï¼Œæœ‰çš„æ˜¯åœ¨ä¸€å¼€å§‹å°±åˆ†é…å¥½ï¼Œæœ‰çš„æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œä½†ä¸€èˆ¬æ¥è¯´thread_localå˜é‡çš„æ€§èƒ½ä¸€èˆ¬ä¸é«˜äºå…¨å±€å˜é‡ã€‚

### mutex

é€šè¿‡mutexï¼Œå¯¹æŸæ®µä¸´ç•ŒåŒºè¿›è¡Œäº’æ–¥è®¿é—®ï¼Œå¯ä»¥é€šè¿‡lock_guardè¿›è¡Œç®€åŒ–ï¼Œlock_guardæ˜¯æŒ‰ç…§RAIIçš„æ–¹å¼è¿›è¡Œmutexç®¡ç†ã€‚

```cpp
std::mutex my_mutex;
int main(int argc, char *argv[])
{
	{
		std::cout << "block in" << std::endl;
		std::lock_guard<std::mutex> lock(my_mutex);
		test t;
		std::cout << "block out" << std::endl;
	}
	std::cout << "out" << std::endl;
	return 0;
}
```

### condition_variable

å¦‚æœå¯¹æŸä¸ªæ•°æ®çš„å¤„ç†ï¼Œçº¿ç¨‹é—´å­˜åœ¨ååºå…³ç³»ï¼Œé‚£ä¹ˆé€šè¿‡ä¿¡å·é‡è¿›è¡ŒåŒæ­¥ï¼›c++11ä¸­çš„ä¿¡å·é‡æ˜¯condition_variableï¼š

```cpp
void waitingForWork(){
    std::cout << "Waiting " << std::endl;
    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck);                       // (1)
    std::cout << "Running " << std::endl;
}

void setDataReady(){
    std::cout << "Data prepared" << std::endl;
    condVar.notify_one();                   // (2)
}
```

## çº¿ç¨‹çš„æ‰§è¡Œä¸é€€å‡º

### CPU affinity

åœ¨Linuxä¸‹ï¼Œé€šè¿‡å‘½ä»¤tasksetæˆ–ç³»ç»Ÿè°ƒç”¨ï¼ˆ`sched_getaffinity`ï¼‰å¯ä»¥è®¾å®šprocessä¸æŸä¸ªCPUæ ¸çš„ç»‘å®šå…³ç³»ï¼›å¦‚æœé€šè¿‡pthreadè¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œå¯ä»¥é€šè¿‡`pthread_setaffinity_np`æˆ–`pthread_attr_setaffinity_np`è¿›è¡Œçº¿ç¨‹ä¸CPUçš„ç»‘å®šã€‚é‚£ä¹ˆï¼Œåœ¨C++11ä¸­ï¼Œå¯é€šè¿‡`threads[i].native_handle()`è·å¾—threadåœ¨å½“å‰å¹³å°çš„IDï¼Œç„¶åé€šè¿‡ç›¸åº”çš„æ–¹å¼è¿›è¡ŒCPUç»‘å®šï¼š

```cpp
// Create a cpu_set_t object representing a set of CPUs. Clear it and mark
// only CPU i as set.
cpu_set_t cpuset;
CPU_ZERO(&cpuset);
CPU_SET(1, &cpuset);
int rc = pthread_setaffinity_np(my_threads.native_handle(),
                                sizeof(cpu_set_t), &cpuset);
if (rc != 0) {
  std::cerr << "Error calling pthread_setaffinity_np: " << rc << "\n";
}
```

### å¿«é€Ÿé€€å‡º

è¿›ç¨‹é€€å‡ºæ—¶ï¼Œå¦‚æœæ˜¯å¼‚å¸¸é€€å‡ºï¼Œä¸€èˆ¬èµ°`abort`ï¼Œè¿™æ—¶ä¸ä¼šè¿›è¡Œææ„å‡½æ•°çš„è°ƒç”¨ï¼Œæœ‰å¯èƒ½ä¼šäº§ç”Ÿcoredumpï¼›å¦‚æœæ˜¯æ­£å¸¸é€€å‡ºï¼Œä¸€èˆ¬èµ°`exit`ï¼Œè¿™æ—¶ä¼šè¿›è¡Œææ„å‡½æ•°çš„è°ƒç”¨ï¼Œä¹Ÿä¼šè°ƒç”¨`atexit`æ³¨å†Œçš„æ¸…ç†å‡½æ•°ã€‚æœ‰æ—¶ä¸ºäº†å¿«é€Ÿæ­£å¸¸é€€å‡ºï¼Œä¸æƒ³èµ°å¤§é‡çš„ææ„å‡½æ•°ï¼Œåœ¨C++11ä¸­ï¼Œæä¾›äº†`quick_exit`ä»¥åŠå¯¹åº”çš„`at_quick_exit`æ¥å£ã€‚

> å¯é‡å…¥ï¼ˆreentrantï¼‰å‡½æ•°ã€çº¿ç¨‹å®‰å…¨ï¼ˆthread-safeï¼‰å‡½æ•°ã€å¹‚ç­‰ï¼ˆidempotenceï¼‰å‡½æ•°ï¼š
>
> é¦–å…ˆè¿™ä¸¤ä¸ªæ¦‚å¿µæ²¡æœ‰ä»»ä½•åŒ…å«å…³ç³»ï¼Œä¸€ä¸ªå‡½æ•°å¯ä»¥æ»¡è¶³ä¸¤è€…ä¹Ÿå¯ä»¥ä¸¤è€…éƒ½ä¸æ»¡è¶³ï¼Œæˆ–åªæ»¡è¶³å…¶ä¸­ä¸€ä¸ªã€‚
>
> å¯é‡å…¥æ¦‚å¿µçš„æå‡ºæ˜¯åœ¨å•è¿›ç¨‹å•çº¿ç¨‹çš„èƒŒæ™¯ä¸‹ï¼Œæ„æ€æ˜¯å‡½æ•°åœ¨æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥ä¸­æ–­å½“å‰æ‰§è¡Œï¼Œå†æ¬¡è°ƒç”¨è¯¥å‡½æ•°ï¼Œè€Œä¸ä¼šå‡ºé”™ï¼Œå½“å‰çš„æ‰§è¡Œå‡½æ•°ä¹Ÿä¸ä¸€å®šä¼šç­‰å¾…ã€‚å…¶å¸¸è§çš„åœºæ™¯æ˜¯å‘ç”Ÿäº†ç¡¬ä»¶ä¸­æ–­æˆ–å‡½æ•°é€’å½’è°ƒç”¨ï¼Œ



**å‚è€ƒ**

[futex overview](https://eli.thegreenplace.net/2018/basics-of-futexes/#id9)

[trap of mutex&condition_var](https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables)

[reentrance func](https://en.wikipedia.org/wiki/Reentrancy_(computing))

[condition value](http://mysql.taobao.org/monthly/2017/01/01/)
